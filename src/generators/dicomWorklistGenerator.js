const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Load environment variables
require('dotenv').config();

/**
 * DICOM Worklist Generator
 * Creates proper DICOM worklist files for Orthanc using DCMTK tools
 */
class DicomWorklistGenerator {
  constructor() {
    // Get worklist directory from environment variable with fallback
    let worklistPath = process.env.ORTHANC_WORKLIST_DIR;
    
    if (!worklistPath) {
      // Default fallback path
      worklistPath = path.join('f:', 'PROJECT', 'hasta-pacs', 'orthanc-mwl', 'worklists');
    } else if (!path.isAbsolute(worklistPath)) {
      // If relative path, resolve from current working directory
      worklistPath = path.resolve(process.cwd(), worklistPath);
    }
    
    this.worklistDir = worklistPath;
    console.log(`📁 Worklist directory configured: ${this.worklistDir}`);
    this.ensureWorklistDirectory();
  }

  async ensureWorklistDirectory() {
    try {
      await fs.access(this.worklistDir);
    } catch {
      await fs.mkdir(this.worklistDir, { recursive: true });
    }
  }

  async generateWorklistFile(worklistData) {
    // Extract and format data
    const data = this.prepareWorklistData(worklistData);
    
    // Generate filename
    const filename = `${data.accessionNumber}_${Date.now()}.wl`;
    const filepath = path.join(this.worklistDir, filename);

    // Create DICOM template
    const template = this.createDicomTemplate(data);
    
    // Try DCMTK conversion first, fallback to simple text
    try {
      await this.convertWithDCMTK(template, filepath);
    } catch (error) {
      console.warn('DCMTK conversion failed, using text template');
      await fs.writeFile(filepath, template);
    }
    
    const stats = await fs.stat(filepath);
    return {
      filename,
      filepath,
      size: stats.size
    };
  }

  prepareWorklistData(worklistData) {
    const {
      patientId,
      patientName,
      patientBirthDate,
      patientSex,
      studyInstanceUID,
      accessionNumber,
      studyDescription,
      scheduledDate,
      scheduledTime,
      modality = 'CR',
      scheduledStationAETitle = 'ORTHANC',
      scheduledProcedureStepDescription,
      requestedProcedureDescription,
      referringPhysician = '',
      performingPhysician = '',
      institutionName = 'Hasta Radiologi',
      departmentName = 'Radiology'
    } = worklistData;

    this.validateRequiredFields(worklistData);

    return {
      patientId,
      patientName: this.formatPatientName(patientName),
      patientBirthDate: this.formatDate(patientBirthDate),
      patientSex: (patientSex || 'U').toUpperCase(),
      studyInstanceUID: studyInstanceUID || this.generateUID(),
      accessionNumber,
      studyDescription: studyDescription || '',
      scheduledDate: this.formatDate(scheduledDate),
      scheduledTime: this.formatTime(scheduledTime),
      modality,
      scheduledStationAETitle,
      scheduledProcedureStepDescription: scheduledProcedureStepDescription || '',
      requestedProcedureDescription: requestedProcedureDescription || '',
      referringPhysician,
      performingPhysician,
      institutionName,
      departmentName
    };
  }

  createDicomTemplate(data) {
    return `# DICOM Worklist Template - Generated by Hasta Radiologi
(0008,0050) SH [${data.accessionNumber}]                    # Accession Number
(0010,0010) PN [${data.patientName}]                       # Patient Name  
(0010,0020) LO [${data.patientId}]                         # Patient ID
(0010,0030) DA [${data.patientBirthDate}]                  # Patient Birth Date
(0010,0040) CS [${data.patientSex}]                        # Patient Sex
(0020,000D) UI [${data.studyInstanceUID}]                  # Study Instance UID
(0032,1032) PN [${data.referringPhysician || 'UNKNOWN^PHYSICIAN'}] # Requesting Physician
(0008,0080) LO [${data.institutionName}]                   # Institution Name
(0008,1040) LO [${data.departmentName}]                    # Institution Department Name
(0040,0100) SQ                                             # Scheduled Procedure Step Sequence
  (fffe,e000) na                                           # Item 
    (0008,0060) CS [${data.modality}]                      # Modality
    (0040,0001) AE [${data.scheduledStationAETitle}]       # Scheduled Station AE Title
    (0040,0002) DA [${data.scheduledDate}]                 # Scheduled Procedure Step Start Date
    (0040,0003) TM [${data.scheduledTime}]                 # Scheduled Procedure Step Start Time
    (0040,0006) PN [${data.performingPhysician || 'UNKNOWN^PHYSICIAN'}] # Scheduled Performing Physician Name
    (0040,0007) LO [${data.scheduledProcedureStepDescription}] # Scheduled Procedure Step Description
    (0040,0009) SH [${data.accessionNumber}_SPS]           # Scheduled Procedure Step ID
  (fffe,e00d) na                                           # Item Delimitation Item
(fffe,e0dd) na                                             # Sequence Delimitation Item`;
  }

  async convertWithDCMTK(template, outputPath) {
    const tempFile = path.join(this.worklistDir, `temp_${Date.now()}.txt`);
    
    try {
      // Write template
      await fs.writeFile(tempFile, template);
      
      // Copy to container
      await execAsync(`docker cp "${tempFile}" dcmtk-client:/tmp/worklist_temp.txt`);
      
      // Convert
      await execAsync(`docker exec dcmtk-client dump2dcm /tmp/worklist_temp.txt /tmp/worklist_temp.wl`);
      
      // Copy back
      await execAsync(`docker cp dcmtk-client:/tmp/worklist_temp.wl "${outputPath}"`);
      
      // Cleanup
      await fs.unlink(tempFile);
    } catch (error) {
      // Cleanup on error
      try { await fs.unlink(tempFile); } catch {}
      throw error;
    }
  }

  async generateBatch(worklistsData) {
    const results = [];
    for (const data of worklistsData) {
      try {
        const result = await this.generateWorklistFile(data);
        results.push({ success: true, data: result });
      } catch (error) {
        results.push({ success: false, error: error.message, data });
      }
    }
    return results;
  }

  async listWorklistFiles() {
    try {
      const files = await fs.readdir(this.worklistDir);
      const worklistFiles = files.filter(file => file.endsWith('.wl'));
      
      const fileDetails = await Promise.all(
        worklistFiles.map(async (file) => {
          const filepath = path.join(this.worklistDir, file);
          const stats = await fs.stat(filepath);
          return {
            filename: file,
            filepath,
            size: stats.size,
            created: stats.birthtime,
            modified: stats.mtime
          };
        })
      );
      
      return fileDetails.sort((a, b) => b.created - a.created);
    } catch (error) {
      return [];
    }
  }

  async deleteWorklistFile(filename) {
    try {
      const filepath = path.join(this.worklistDir, filename);
      await fs.unlink(filepath);
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  validateRequiredFields(data) {
    const required = ['patientId', 'patientName', 'accessionNumber'];
    const missing = required.filter(field => !data[field]);
    if (missing.length > 0) {
      throw new Error(`Missing required fields: ${missing.join(', ')}`);
    }
  }

  formatPatientName(name) {
    if (!name) return 'UNKNOWN^PATIENT';
    if (name.includes('^')) return name;
    
    if (name.includes(', ')) {
      const [last, first] = name.split(', ');
      return `${last.trim()}^${first.trim()}`;
    } else {
      const parts = name.trim().split(' ');
      if (parts.length >= 2) {
        const last = parts.pop();
        const first = parts.join(' ');
        return `${last}^${first}`;
      }
      return `${parts[0]}^`;
    }
  }

  formatDate(date) {
    if (!date) return new Date().toISOString().slice(0, 10).replace(/-/g, '');
    try {
      return new Date(date).toISOString().slice(0, 10).replace(/-/g, '');
    } catch {
      return new Date().toISOString().slice(0, 10).replace(/-/g, '');
    }
  }

  formatTime(time) {
    if (!time) return new Date().toTimeString().slice(0, 8).replace(/:/g, '');
    try {
      let timeStr = time.toString().replace(/[^\d:]/g, '');
      if (timeStr.includes(':')) {
        const parts = timeStr.split(':');
        return parts.map(p => p.padStart(2, '0')).join('').slice(0, 6).padEnd(6, '0');
      }
      return timeStr.padEnd(6, '0').slice(0, 6);
    } catch {
      return new Date().toTimeString().slice(0, 8).replace(/:/g, '');
    }
  }

  generateUID() {
    const root = '1.2.826.0.1.3680043.8.498';
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000);
    return `${root}.${timestamp}.${random}`;
  }
}

module.exports = DicomWorklistGenerator;
